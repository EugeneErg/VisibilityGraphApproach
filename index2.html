<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Manipulation</title>
    <script src="/scripts/vue.global.js"></script>
    <style>
        body {
            margin: 0;
            background-color: #f5f7fa;
            font-family: Arial, sans-serif;
            height: 100vh;
            user-select: none;
        }
        #app {
            display: flex;
            height: 100%;
        }
        .toolbar {
            width: 200px;
            background-color: #e8ebf0;
            padding: 10px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }
        .toolbar button {
            display: block;
            width: 100%;
            margin-bottom: 10px;
            padding: 10px;
            font-size: 14px;
            cursor: pointer;
        }
        .svg-container {
            flex: 1;
            position: relative;
        }
        svg {
            width: 100%;
            height: 100%;
            display: block;
        }
        circle {
            cursor: pointer;
        }
    </style>
</head>
<body>
<div id="app">
    <div class="toolbar">
        <button @click="setTool('add')">Add</button>
        <button @click="setTool('remove')">Remove</button>
        <button @click="setTool('move')">Move</button>
    </div>
    <div class="svg-container">
        <svg :view-box.camel="viewBox" xmlns="http://www.w3.org/2000/svg"
             @mousedown="startDrag($event)"
             @mousemove="drag($event)"
             @mouseup="endDrag"
             @wheel="onScroll">
            <polygon :points="visiblePoints.map(p => `${p.x},${p.y}`).join(' ')" fill="rgba(0,255,0,0.5)"/>
            <line v-for="line in lines"
                  :x1="line.x1" :y1="line.y1" :x2="line.x2" :y2="line.y2"
                  stroke="rgba(0,0,255,0.5)" stroke-width="2" stroke-dasharray="5, 5"/>
            <circle v-for="(point, index) in points"
                    :cx="point.x" :cy="point.y" r="10"
                    fill="blue" @mousedown.stop="selectPoint(index, $event)" />
            <text v-for="(point, index) in points"
                  :x="point.x + 12" :y="point.y + 4"
                  font-size="12" fill="black">
                {{ index + 1 }}
            </text>
            <circle :cx="observer.x" :cy="observer.y" r="10"
                    fill="black" @mousedown.stop="startObserverDrag($event)" />
        </svg>
    </div>
</div>
<script>
    class Part {
        previous = null;
        next = null;
        nextConnected = false;

        constructor(point, angle, distance) {
            this.point = point;
            this.angle = angle;
            this.distance = distance;
        }

        getPreviousConnected() {
            return this.previous?.getNextConnected() ?? false;
        }

        getNextConnected() {
            return this.nextConnected;
        }

        unsetPrevious() {
            this.previous?.unsetNext();
        }

        setPrevious(previous, connected) {
            previous.setNext(this, connected);
        }

        unsetNext() {
            if (this.next !== null) {
                this.next.previous = null;
            }
            this.next = null;
        }

        setNext(next, connected) {
            this.next?.unsetPrevious();
            this.next = next;
            this.nextConnected = connected;
            next.unsetPrevious();
            next.previous = this;
        }

        addPrevious(previous, connected) {
            previous.addNext(this, connected);
        }

        addNext(next, connected) {
            next.setNext(this.next, this.nextConnected);
            this.setNext(next, connected);
        }

        getNext() {
            return this.next;
        }
    }
    class Angle {
        constructor(value = 0) {
            this.value = value;
        }

        static pi(value = 1) {
            return new Angle(Math.PI * value);
        }

        static degrees(value = 0) {
            return new Angle((value * Math.PI) / 180);
        }

        static radian(value = 0) {
            return new Angle(value);
        }

        static percent(value = 0) {
            return new Angle((value * Math.PI) / 50);
        }

        static asin(num) {
            const result = Math.asin(num);
            if (isNaN(result)) {
                throw new Error(String(num));
            }
            return new Angle(result);
        }

        static max(...angles) {
            return angles.reduce((result, next) =>
                    result === null || next.greaterThan(result) ? next : result
                , null);
        }

        greaterThan(angle) {
            return this.value > angle.value;
        }

        lessThanOrEqual(angle) {
            return this.value <= angle.value;
        }

        lessThan(angle) {
            return this.value < angle.value;
        }

        greaterThanOrEqual(angle) {
            return this.value >= angle.value;
        }

        modulo() {
            const result = this.value % (Math.PI * 2);
            return new Angle(result + (result < 0 ? Math.PI * 2 : 0));
        }

        absolute() {
            return new Angle(Math.abs(this.value));
        }

        minus(angle) {
            return new Angle(this.value - angle.value);
        }

        plus(angle) {
            return new Angle(this.value + angle.value);
        }

        getPi() {
            return this.value / Math.PI;
        }

        getDegrees() {
            return (this.value * 180) / Math.PI;
        }

        getRadian() {
            return this.value;
        }

        getPercent() {
            return (this.value * 50) / Math.PI;
        }

        isPositive() {
            return this.value > 0;
        }

        between(from, to) {
            return from.lessThan(to)
                ? this.greaterThan(from) && this.lessThan(to)
                : this.greaterThan(from) || this.lessThan(to);
        }

        in(curve) {
            return this.between(curve.from, curve.to);
        }

        isEqual(angle, delta = 0.00000001) {
            return this.minus(angle).absolute().lessThan(new Angle(delta));
        }

        divided(divider) {
            return new Angle(this.value / divider);
        }

        times(multiplier) {
            return new Angle(this.value * multiplier);
        }

        sin() {
            return Math.sin(this.value);
        }

        cos() {
            return Math.cos(this.value);
        }
    }
    class Point {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }

        isEqual(other) {
            return this.x === other.x && this.y === other.y;
        }
    }

    class State
    {
        constructor(
            visible,
            firstPart,
            lastPart,
        ) {
            this.visible = visible;
            this.firstPart = firstPart;
            this.lastPart = lastPart;
        }
    }

    const app = Vue.createApp({
        data() {
            return {
                tool: 'add',
                points: [],
                lines: [],
                observer: new Point(100, 100),
                draggingPoint: null,
                draggingObserver: false,
                offsetX: 0,
                offsetY: 0,
                viewBox: '0 0 800 600',
                isPanning: false,
                panStart: { x: 0, y: 0 }
            };
        },
        methods: {
            setTool(tool) {
                this.tool = tool;
            },
            startDrag(event) {
                if (this.tool === 'add') {
                    const coords = this.getSVGCoordinates(event);
                    this.points.push(coords);
                    this.updateLines();
                } else if (event.target.tagName !== 'circle') {
                    this.isPanning = true;
                    const [x, y] = this.viewBox.split(' ').map(Number);
                    this.panStart = { x, y, clientX: event.clientX, clientY: event.clientY };
                }
            },
            getSVGCoordinates(event) {
                const svg = event.target.closest('svg');
                const point = svg.createSVGPoint();
                point.x = event.clientX;
                point.y = event.clientY;
                const ctm = svg.getScreenCTM().inverse();
                const transformed = point.matrixTransform(ctm);
                return new Point(transformed.x, transformed.y);
            },
            selectPoint(index, event) {
                if (this.tool === 'remove') {
                    this.points.splice(index, 1);
                    this.updateLines();
                } else if (this.tool === 'move') {
                    this.draggingPoint = index;
                    const coords = this.getSVGCoordinates(event);
                    this.offsetX = this.points[index].x - coords.x;
                    this.offsetY = this.points[index].y - coords.y;
                }
            },
            drag(event) {
                if (this.draggingPoint !== null) {
                    const coords = this.getSVGCoordinates(event);
                    this.points[this.draggingPoint].x = coords.x + this.offsetX;
                    this.points[this.draggingPoint].y = coords.y + this.offsetY;
                    this.updateLines();
                } else if (this.draggingObserver) {
                    const coords = this.getSVGCoordinates(event);
                    this.observer.x = coords.x + this.offsetX;
                    this.observer.y = coords.y + this.offsetY;
                } else if (this.isPanning) {
                    const dx = event.clientX - this.panStart.clientX;
                    const dy = event.clientY - this.panStart.clientY;
                    const [, , width, height] = this.viewBox.split(' ').map(Number);
                    this.viewBox = `${this.panStart.x - dx} ${this.panStart.y - dy} ${width} ${height}`;
                }
            },
            endDrag() {
                this.draggingPoint = null;
                this.draggingObserver = false;
                this.isPanning = false;
            },
            startObserverDrag(event) {
                const coords = this.getSVGCoordinates(event);
                this.offsetX = this.observer.x - coords.x;
                this.offsetY = this.observer.y - coords.y;
                this.draggingObserver = true;
            },
            updateLines() {
                this.lines = [];
                for (let i = 0; i < this.points.length; i++) {
                    const nextIndex = (i + 1) % this.points.length;
                    this.lines.push({
                        x1: this.points[i].x,
                        y1: this.points[i].y,
                        x2: this.points[nextIndex].x,
                        y2: this.points[nextIndex].y
                    });
                }
            },
            onScroll(event) {
                const [x, y, width, height] = this.viewBox.split(' ').map(Number);
                const scaleFactor = 0.1;
                const delta = event.deltaY > 0 ? 1 + scaleFactor : 1 - scaleFactor;
                const newWidth = width * delta;
                const newHeight = height * delta;

                const svg = event.target.closest('svg');
                const point = svg.createSVGPoint();
                point.x = event.clientX;
                point.y = event.clientY;
                const ctm = svg.getScreenCTM().inverse();
                const transformed = point.matrixTransform(ctm);

                const offsetX = (transformed.x - x) * (1 - delta);
                const offsetY = (transformed.y - y) * (1 - delta);

                this.viewBox = `${x + offsetX} ${y + offsetY} ${newWidth} ${newHeight}`;
            },
            getAngle(visorCoordinate, vertexCoordinate) {
                if (visorCoordinate.isEqual(vertexCoordinate)) {
                    return new Angle();
                }
                return new Angle(Math.atan2(
                    visorCoordinate.y - vertexCoordinate.y,
                    visorCoordinate.x - vertexCoordinate.x
                )).modulo();
            },
            getDistance(visorCoordinate, vertexCoordinate) {
                return (
                    (visorCoordinate.y - vertexCoordinate.y) ** 2 +
                    (visorCoordinate.x - vertexCoordinate.x) ** 2
                );
            },
            getRelativeAngle(previousAngle, currentAngle) {
                const result = currentAngle.minus(previousAngle).modulo();

                return result.greaterThan(Angle.pi())
                    ? Angle.pi().minus(result)
                    : result;
            },
            getType(angle, start, end) {
                if (angle.isEqual(start)) {
                    return 'start';
                }

                if (angle.isEqual(end)) {
                    return 'end';
                }

                return angle.between(start, end)
                    ? 'in'
                    : 'out';
            },
            /** @returns State */
            usePart(state, previousPart, currentPart) {
                var shiftAngle = this.getRelativeAngle(previousPart.angle, currentPart.angle);
                var lineDirectionAsc = shiftAngle.isPositive();
                var previousType = this.getType(previousPart.angle, state.firstPart.angle, state.lastPart.angle);
                var currentType = this.getType(currentPart.angle, state.firstPart.angle, state.lastPart.angle);
                console.log(
                    currentPart.angle.getDegrees(),
                    shiftAngle.getDegrees(),
                    lineDirectionAsc,
                    previousType,
                    currentType,
                );

                if (lineDirectionAsc) {
                    //движемся вперед
                    if (previousType === 'end' && currentType === 'out') {
                        state.lastPart.setNext(currentPart, true);

                        return new State(
                            state.lastPart.point.isEqual(previousPart.point),
                            state.firstPart,
                            currentPart,
                        );
                    }

                    if (previousType === 'end' && currentType === 'end') {
                        if (currentPart.distance > state.lastPart.distance) {
                            return new State(
                                false,
                                state.firstPart,
                                state.lastPart,
                            );
                        }

                        state.lastPart.setNext(currentPart, true);

                        return new State(
                            state.lastPart.point.isEqual(previousPart.point),
                            state.firstPart,
                            currentPart,
                        );
                    }

                    if (previousType === 'end' && currentType === 'start') {
                        //хоть линия и соединяет первый и последний угол видимой кривой, но она может пересекать кривую
                        //необходима доп проверка.

                        state.lastPart.setNext(currentPart, true);

                        return new State(
                            state.lastPart.point.isEqual(previousPart.point),
                            state.firstPart,
                            currentPart,
                        );
                    }


                    console.log('equals', state.firstPart === currentPart);
                    state.lastPart.setNext(currentPart);
                    console.log('add');
                } else {
                    //движемся назад
                    for (
                        var root = state.lastPart;
                        root !== null && root.angle.greaterThan(currentPart.angle);
                        root = root.previous
                    ) {
                    }

                    if (root === null) {
                        return new State(true, currentPart, currentPart);
                    }

                    root.setNext(currentPart);

                    return new State(
                        true,
                        state.firstPart,
                        currentPart,
                    );
                }

                return lineDirectionAsc
                    ? new State(
                        true,
                        state.firstPart,
                        currentPart,
                    )
                    : state;
            },
            findIntersectBack(previousPart, currentPart, state) {
                var currentDistanceGreaterThanVisible = undefined;

                if (state.lastPart.angle.isEqual(previousPart)) {
                    currentDistanceGreaterThanVisible = state.lastPart.distance === previousPart.distance
                        ? null
                        : state.lastPart.distance < previousPart.distance;
                }

                for (
                    var part = state.lastPart;
                    part !== null;
                    part = part.previous
                ) {
                    if (currentDistanceGreaterThanVisible === undefined) {

                    }


                    //previousPart.angle.between(state.lastPart.angle, state.firstPart.angle)
                }


                this.observer;

            },
        },
        computed: {
            visiblePoints() {
                var state = null;
                var previousPart = null;
                var firstPart = null;
                console.clear();

                for (const point of this.points) {
                    const currentPart = new Part(
                        point,
                        this.getAngle(this.observer, point),
                        this.getDistance(this.observer, point),
                    );

                    if (previousPart === null) {
                        firstPart = previousPart = currentPart;
                        state = new State(true, previousPart, previousPart);
                        console.log(currentPart.angle.getDegrees());

                        continue;
                    }

                    state = this.usePart(state, previousPart, currentPart);
                    previousPart = currentPart;
                }

                var result = [];

                if (firstPart !== null) {
                    state = this.usePart(state, previousPart, firstPart);
                    var firstRoot = null;

                    for (
                        var root = state.firstPart;
                        root !== null;
                        root = root.getNext()
                    ) {
                        if (root === firstRoot) {
                            root = null;
                            break;
                        }

                        if (firstRoot === null) {
                            firstRoot = root;
                        }

                        console.log('push', root);
                        result.push(root.point);
                    }
                }

                return result;

            }
        }
    });

    app.mount('#app');
</script>
</body>
</html>